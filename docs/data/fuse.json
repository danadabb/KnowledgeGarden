{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Knowledge Garden","n":0.707},"1":{"v":"\n#### My Second Brain\n\n---\n\nA collection of my notes around all things software development.\n\n> This website is generated by a Dendron template. For more information, see the [template README file](https://github.com/dendronhq/template.publish.github/).\n","n":0.186}}},{"i":2,"$":{"0":{"v":"Web","n":1}}},{"i":3,"$":{"0":{"v":"Frontend","n":1}}},{"i":4,"$":{"0":{"v":"Web Components","n":0.707},"1":{"v":"\nWeb components allow you to create custom reusable and encapuslated HTML tags to be used in web pages and apps. They are capable of isolating CSS and JavaScript similar to `<iframe>` - known as a **shadown DOM**. These are framework agnostic and are supported by most modern browsers.\n\nExample:\n\n```JavaScript\n// CREATE\nclass MyButton extends HTMLElement {...}\nwindow.customElements.define('my-button', MyButton);\n\n// USE\n<my-button></my-button>\n```\n\n### Web Components vs React\n\nAccording to [React documentation](https://reactjs.org/docs/web-components.html#:~:text=React%20and%20Web%20Components%20are,The%20two%20goals%20are%20complementary.), Web Components and React solve different problems. React is a declarative JS library to address state management and web app \"reactivity\". Web components exist to address reusability and encapsulation of HTML elements. React components can only be used in React, where as web components can be used anywhere e.g. across different libraries - Vue, React, Angular etc.\n","n":0.092}}},{"i":5,"$":{"0":{"v":"Rendering Design Patterns","n":0.577},"1":{"v":"\n## CSR (Client-Side Rendering) / SPA (Single Page Application)\n\n> the data is fetched after every single render\n\nMost common way of using frameworks such as React, vue, ember etc.\n\nClient-side rendering means that a website’s JavaScript is rendered in your browser, rather than on the website’s server.\n\n- The server renders a blank page with a script tag pointing to the apps bundle\n- blank page is sent to the clients browser which makes the relevant api calls and renders the contents of the page\n\nstrengths:\n\n- renders fast on the server\n\nweaknesses:\n\n- no initial render - customer/client has to render so if the app is big it could be a problem\n\n- empty body - no content to crawl for a search engine - ** SEO is the biggest weak point **\n\n## SSR (Server Side Rendering)\n\n> the data is fetched before every single render\n\nWhen the user makes a request to the webpage, the server prepares the html page and then sends it back.\n\n## SSG (Static-Site Generating)\n\n> the data is fetched once at build time\n\nPage is also generated on the server however it is rendered at **build time.**\n\n## ISR (Incremental Static Regeneration)\n\n> the data is fetched once on build time and will be fetched again after a certain cooldown and served on the second visit.\n\nAllows you to create or update static pages after you've built your site. This gives you the benefit of using static generation without needing to rebuild the entire site.\n\n## When to use what?\n\n- Is your content dynamic or relatively static?\n\n- is SEO important?\n\nHere are some examples from [this article](https://medium.com/codex/web-design-patterns-ssr-ssg-and-spa-fadad7673dfe#:~:text=SSR%20vs%20SSG,I%20use%20SSR%20then%3F%22.)\n\n> For a documentation page or a website that doesn't need to fetch dynamic data, but SEO is important, you could use SSG.\n> For a blog, SEO is important and the content is dynamic. In this case, SSR could be a good candidate.\n> For a CRM (Customer Relationship Manager), SEO is not a concern and the content is dynamic therefore an SPA/CSR would be a good choice.\n\nMany websites will use a combination. These days for anything that is not an SPA, it's often recommended to use SSG practically all of the time unless there is a good reason not to e.g. the website is massive with dynamic content that cannot be pre-rendered as it changes frequently. [Next JS recommends SSG ](https://nextjs.org/docs/basic-features/pages#pre-rendering) for many use cases. The alternative is to use ISR for a website with mostly static content but for a web page with thousands of pages in order to prevent a complete rebuild every time.\n\n> \"We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option.\"\n\nSome important considerations:\n\n1. Data Integrity - how fresh do we want the data? CSR and SSR fetch on every render.\n\n2. SEO - SSR, SSG and ISR are SEO friendly given crawlers don't have to wait for a page to load to get relevant data\n3. Performance - SSG and ISR load instantly (for first contentful paint)\n4. Build Time - the amount of time it takes to build and deploy the website is slower for SSG and ISR since we need to build all the pages to serve where as CSR and ISR build pages dynamically.\n\n##### References\n\n1. https://theodorusclarence.com/blog/nextjs-fetch-usecase\n","n":0.043}}},{"i":6,"$":{"0":{"v":"Backend","n":1}}},{"i":7,"$":{"0":{"v":"Database","n":1},"1":{"v":"\n## Types\n\n### Relational (SQL)\n\nInformation is stored in tables, in rows and columns. Tables usually have relationships with other tables.\n\nStructured Query Language (SQL) is used to interact with relational databases.\n\nExamples:\n\n- Microsoft SQL Server\n- MySQL\n- PostgresSQL\n\nAdvantages of using a relational database include:\n\n**ACID Compliance**\n\nAtomicity, Consistency, Isolation, Durability (ACID) is a standard that guarantees the reliability of database transactions. ACID transactions are a group of database operations that succeed only if all the operations within succeed. This ensures that the database remains in a consistent state and there are no dangling incomplete mutations.\n\nTo understand this, we can think of a bank transfer where we transfer from one account to another. Here we expect that in our first account, we expect both accounts to reflect a new transaction e.g. $100 from ACC1 to ACC2:\n\n```SQL\nUPDATE bankaccounts SET funds=funds-100 WHERE accountno='ACC1';\nUPDATE bankaccounts SET funds=funds+100 WHERE accountno='ACC2';\n```\n\nIf our second statement were to fail, the accuracy of the database would be compromised. In order to fix this, we use a transaction:\n\n```SQL\nSTART TRANSACTION or BEGIN; -- Wrap the statements in a transaction\nUPDATE bankaccounts SET funds=funds-100 WHERE accountno='ACC1'; --statement2\nUPDATE bankaccounts SET funds=funds+100 WHERE accountno='ACC2'; --statement3\nCOMMIT; -- COMMIT to DB once all statements pass successfully\n```\n\n**Data Accuracy**\n\nPrimary and foreign keys ensure there is no duplication.\n\n### Non-relational (No SQL)\n\n### Relational or Non-relational?\n\n#### References\n\n1. https://www.softwaretestinghelp.com/mysql-transaction-tutorial/\n2. https://www.mongodb.com/basics/acid-transactions\n3. https://www.mongodb.com/compare/relational-vs-non-relational-databases\n","n":0.069}}},{"i":8,"$":{"0":{"v":"API Architecture","n":0.707},"1":{"v":"\nA note describing some of the different API architectures/protocols, namely RPC, REST and GraphQL.\n\n## RPC - Remote Procedure Call\n\nEarliest API architecture. Remote Procedure Call (RPC), as the name implies, calls a remote \"[procedure](programming-paradigms#procedural-programming,1:#*)\" or a function e.g. from a client application to the API on a server.\n\nHow the procedure/function is invoked on the server depends on the framework and choice of technology adopted. RPC is just a concept, and in a simple scenario, the method called could be determined by simply parsing query parameters from the url coming from the client and performing a string comparison, matching the method from the client to the server.\n\nA contrived example where a client invokes the API to perform mathematical operations on two numbers 'a' and 'b' and return the result:\n\n```Javascript\n/** Server API **/\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/',(req, res) => {\n  // extract the method being called from the query params\n  // URL is in the format http(s)://<host>/method=<methodName>&b=<b>&c=<c>\n  const { method } = req.query;\n  const a = parseInt(req.query.a);\n  const b = parseInt(req.query.b);\n\n  let methodResponse = \"\";\n\n  // call the method requested - here we do a simple string comparison\n  // so that it appears the FE and BE \"share\" procedures\n  switch(method) {\n     case \"add\":\n     \tmethodResponse = add(a,b);\n        break;\n     case \"multiply\":\n     \tmethodResponse = multiply(a,b);\n        break;\n     case \"minus\":\n     \tmethodResponse = minus(a,b);\n\tbreak;\n     default:\n        methodResponse = \"method doesn't exist\";\n\n  }\n\n  res.send({ result: methodResponse });\n})\n\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}\n\nfunction minus(a, b) {\n  return a - b;\n}\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n})\n\n```\n\nA client can communicate to the above API application as follows:\n\n```bash\nGET http://localhost:3000/?method=multiply&a=4&b=2\n{output: 8} #response recieved\n\n```\n\n### Disadvantages\n\n**Tight coupling** - RPCs client and server are tightly coupled since function calls need to match.\n\n**Leaking internal implementation** - It may be considered a flaw that the inner workings of the API are somewhat revealed to the client as the backend method names may be \"telling\".\n\n**Extensibility of methods is difficult** - it's often the case that in RPC API's, a procedure may not perform the exact functionality and hence another method that does something slightly different is added. In this case, there is an overload of similar functions which can be messy:\n\n```javascript\nfunction multiply() {\n  // does something\n}\n\nfunction multiplyV2() {\n  // does something similar to multiply() but different\n}\n\nfunction multiplyV3() {\n  // etc\n}\n```\n\n### Advantages\n\n**Lightweight** - RPC APIs are expected not to return a lot of meta data and the most popular frameworks such as gRPC are built in such a way that allows them to be more performant than their REST counterpart.\n\n**Action-oriented** - RPCs are good for action oriented applications where we are calling 'commands' rather than focusing on resources.\n\n### gRPC\n\nOne of the most notable examples of RPC frameworks in modern day is [gRPC](https://grpc.io/). gRPC is an open-source Google framework used for high performance microservice architecture styles. It's supported by multiple languages/frameworks such as Go, Node, Rust Python and more. It's used by many well known tech companies such as Square, Netlfix and [Cloudflare](https://blog.cloudflare.com/road-to-grpc/).\n\ngRPC is considered highly performant due to:\n\n- Using HTTP/2 for transport\n- Allowing both clients and servers to stream data as opposed to polling (_Note: I believe this is available due to HTTP/2_)\n- Encouraging **Protobuf** as the messaging format\n\nProtobuf (protocol buffers) are a message format that allow for serialization of structured data in a language neutral way. They are an alternative messaging format to others such as JSON or XML and are considered more compact to achieve low latency.\n\nExample of a Protobuf message:\n\n```Protobuf\n// Person.proto\nmessage Person {\n  required string name = 1;\n  required int32 age = 2;\n  optional string email = 3;\n}\n```\n\nProtobufs are encoded in such a way that makes them lightweight and performant.\n\n![](/assets/images/2022-03-03-10-51-00.png)\n\n<caption>Source: https://developers.google.com/protocol-buffers/docs/overview#work</caption>\n<br>\n<br>\n\ngRPC can be implemented using a variety of languages or frameworks, however it seems performance varies - multiple language performance tests are [performed often](https://grpc.io/docs/guides/benchmarking/) on the code base. Note that the [performance dashboard](https://grafana-dot-grpc-testing.appspot.com/?kiosk=tv) is missing Node however, it has been [benchmarked by 3rd parties](https://www.nexthink.com/blog/comparing-grpc-performance/) and _appears_ to be less performant than alternatives such as Go.\n\ngRPC currently cannot natively communicate with the web via HTML/2. Browsers do not support protobuf payloads and hence, grpc-web was introduced in order to act as a proxy to serialize web payload and give developers the ability to use protobufs across the full stack:\n\n![https://grpc.io/blog/state-of-grpc-web/](/assets/images/2022-03-03-10-13-17.png)\n\n<caption>Source: https://grpc.io/blog/state-of-grpc-web/</caption>\n\n</br>\n</br>\nPrior to this, developers would likely use REST APIs with HTTP to communicate with the gRPC backend.\n\n## REST\n\n**Re**presentational **s**tate **t**ransfer (REST) API is an architectural style created by Roy Fielding, described famously in his [dissertation](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).\n\nREST is commonly not adhered to when implemented as many APIs do not tick the architectural constraints that make an API \"RESTful\". There are **6 constraints** which make a web service truly RESTful:\n\n1. **Uniform Interface**\n\nWhat distinguishes REST is uniform interface whereby the client and server are decoupled in such a way that allows them tfcv o evolve independently. Having this interface provides the client with enough information to retrieve the relevant data without having to understand the underlying implementation. This concept is achieved through these four principles:\n\n- **Identification of resources** - where RPCs are command or action oriented, REST APIs are modeled around resources. For example, users in a rest API are handled via the URI `/user`\n\n- **Manipulation of resources through representations** - When a client holds a representation of a resource, including any metadata attached, it has enough information to modify or delete the resource on the server. This makes REST APIs **discoverable** in that from the root of the API, the client has enough information to perform any available action on the available resources.\n\n- **self-descriptive messages** - Each message includes enough information to describe how to process the message. For example, by using standard [MIME Types](https://en.wikipedia.org/wiki/Media_type#cite_note-10) e.g. `application/json`, . Responses also explicitly indicate their cache-ability. e.g. `Cache-Control: max-age=31536000`\n\n- **hypermedia as the engine of application state (HATEOAS)** - allows the client to dynamically navigate to the appropriate resources by traversing the hypermedia links. For example, a call to `GET http://localhost:8080/users` could return:\n\n```JSON\n\n\n```\n\n#### References\n\n1. https://blog.jscrambler.com/rpc-style-vs-rest-web-apis\n2. https://grpc.io/\n3. https://www.restapitutorial.com/lessons/whatisrest.html#\n","n":0.032}}},{"i":9,"$":{"0":{"v":"Projects","n":1}}},{"i":10,"$":{"0":{"v":"Operation Rewrite","n":0.707},"1":{"v":"\n## Project: Operation Re-write (Purposely obscure)\n\n### Problem:\n\nExisting site is slow and difficult to improve given it's built in wordpress. Gives limited options for improvement from a developer perspective without adding more bloat and plugins. Owned by non-for-profit therefore budget is an important consideration.\n\n### Solution:\n\nRe-write using headless CMS and following JAMSTACK princples.\n\n### Existing stack\n\n- Frontend: PHP\n- Backend: PHP\n- CMS: Wordpress\n- DB: SQL\n\n### Proposed re-architected stack:\n\n- Frontend: React framework\n- Backend - possibly NodeJS with GraphQL\n- CMS: Headless\n- DB: ?? not sure if I need one\n\n### Rendering Style\n\nRef [[web.frontend.designpatterns]]\n\nOptions: SSR, SSG, SPA, ISR\n\nContent is mostly static - new blog posts written relatively infrequently. There is an ecommerce section with a small number of products. No comments or anything else that is dynamic at the moment.\n\nSSG could be a good option here but a framework that supports SSR as well could be useful for any future concerns. Maybe best of both worlds and use ISR? No need to rebuild every time we change a post or add a product.\n\n### Framework Options\n\n- Remix - looks good but pretty new\n- Next - established, but maybe bloated for my use case? Needs a server to run for ISR and SSR\n- Gatsby - only does SSG (?)\n\n### Headless CMS Options\n\n- Strapi - free/open source\n- Contentful - recommended but paid after certain point\n\n### DB?\n\nDo I need?\n\n- PSQL\n\n## Build steps\n\n1. Set up CMS\n2. Set up FE\n3. interface the two\n","n":0.066}}},{"i":11,"$":{"0":{"v":"Programming Paradigms","n":0.707},"1":{"v":"\n**Programming paradigm refers to a style of programming.** Programming languages need to follow some strategy when they are implemented known as a paradigm.\n\nThere are two significant paradigms programming languages fall into - **Imperative** and **Declarative**. These categories have various subtypes:\n\n```mermaid\ngraph TD;\n    D[Imperitive]-->P[Procedural];\n    D --> O[Object Oriented]\n```\n\n```mermaid\ngraph TD;\n    D[Declarative]-->L[Logic];\n    D --> F[Functional]\n```\n\n## Imperative\n\nThe word “imperative” comes from the Latin “impero” meaning “I command”. This is the oldest programming paradigm. It effectively means the code is a series of commands executed in order to achieve a result.\n\nImperative tells a program exactly how to do something. For example, if we need a program to print numbers in an array that are less than 10:\n\n```Javascript\n    const nums = [5, 10, 15, 8, 7]\n    let lessThanTen = []\n\n    for(i = 0; i < nums.length; i++) {\n        if(nums[i] < 10) {\n            lessThanTen.push(nums[i]);\n        }\n    }\n\n    // prints [5, 8, 7]\n    console.log(lessThanTen)\n```\n\n## Declarative\n\nDeclarative programming focuses on the end result as opposed to how to get there. For example, if we need a program to print numbers in an array that are less than 10:\n\n```Javascript\n    const nums = [5, 10, 15, 8, 7]\n    // prints [5, 8, 7]\n    console.log(nums.filter(num => num < 10))\n```\n\nReact is a declarative framework as rather than telling it how to render (in the same way you do with vanilla JS), you tell it what you want it to render.\n\n## Types of Imperative Programming\n\n### Procedural Programming\n\nBuilt around the idea that programs are sequences of instructions to be executed - splits up programs into 'procedures' or functions. This is effectively the same as imperative with the idea of using code splitting and enhancing reusability with subroutines.\n\n```Javascript\n    // use a function (procedural)\n    function getNumbersLessThanTen(nums) {\n        let lessThanTen = []\n        for(i = 0; i < nums.length; i++) {\n            if(nums[i] < 10) {\n                lessThanTen.push(nums[i]);\n            }\n        }\n        return lessThanTen\n\n    }\n\n\n    // prints [5, 8, 7]\n    console.log(getNumbersLessThanTen([5, 10, 15, 8, 7]))\n```\n\n### Object-oriented Programming\n\nOOP was introduced in order to overcome procedural programming limitations. In OOP, code is organised into objects and classes. In conventional procedural programming, data was global and there was a difficulty in securing the program from unintended changes. OOP controls access to data via encapsulation within classes.\n\nThe main priniciples of OOP are:\n\n1. Encapsulation\n2. Inheritance\n3. Abstraction\n4. Polymorphism\n\n## Types of Declarative Programming\n\n### Logical programming\n\nMade up of facts and rules and foundationally mathematical. It takes a declarative approach to problem solving by using everything it knows and trying to answer whether the given facts and clauses are true. For example, if the code states that A is equal to B and B is equal to C, a logical program will make the logical conclusion that A must be equal to C.\n\nExamples of languages that use logic programming paradigm are Prolog, Absys or Alice.\n\n### Functional programming\n\nFunctional programming is language independent. FP is the process of building software by composing pure functions, avoiding shared state, mutable data and side effects. JavaScript is a notable example of a language that fundemnatally supports the functional paradigm.\n\nA pure function is one which, given the same inputs, always returns the same output and has no side effects. This is an important aspect of functional programming. The idea is that functions are not dependent on local or global state.\n\nFunctions are described as \"first class objects\" in functional programming. The reason is that functions can be assigned to variables, passed as arguments, and returned from other functions, just as any other data type can.\n\n```JavaScript\n\n// assign function to variable!\nlet log = function(someVariable) {\n    console.log(someVariable);\n    return someVariable;\n}\n\n\nlet myVar = \"Hello world\";\n\nlog(myVar);\n// Hello world\n```\n","n":0.042}}},{"i":12,"$":{"0":{"v":"Agile","n":1},"1":{"v":"\nThe ability to respond to **change**.\n\nAgile software development is iterative, focusing on small increments and evolving requirements.\n\nAgile development refers to any development process that is aligned with the concepts of the Agile [[agile.manifesto]]\n","n":0.174}}},{"i":13,"$":{"0":{"v":"Manifesto","n":1},"1":{"v":"\nTODO\n","n":1}}}]}
