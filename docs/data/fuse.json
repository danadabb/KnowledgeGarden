{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Knowledge Garden","n":0.707},"1":{"v":"\n#### My Second Brain\n\n---\n\nA collection of my notes around all things software development.\n\n> This website is generated by a Dendron template. For more information, see the [template README file](https://github.com/dendronhq/template.publish.github/). Feel free to modify and delete this section.\n","n":0.164}}},{"i":2,"$":{"0":{"v":"Web","n":1}}},{"i":3,"$":{"0":{"v":"Frontend","n":1}}},{"i":4,"$":{"0":{"v":"Web Components","n":0.707},"1":{"v":"\nWeb components allow you to create custom reusable and encapuslated HTML tags to be used in web pages and apps. They are capable of isolating CSS and JavaScript similar to `<iframe>` - known as a **shadown DOM**. These are framework agnostic and are supported by most modern browsers.\n\nExample:\n\n```JavaScript\n// CREATE\nclass MyButton extends HTMLElement {...}\nwindow.customElements.define('my-button', MyButton);\n\n// USE\n<my-button></my-button>\n```\n\n### Web Components vs React\n\nAccording to [React documentation](https://reactjs.org/docs/web-components.html#:~:text=React%20and%20Web%20Components%20are,The%20two%20goals%20are%20complementary.), Web Components and React solve different problems. React is a declarative JS library to address state management and web app \"reactivity\". Web components exist to address reusability and encapsulation of HTML elements. React components can only be used in React, where as web components can be used anywhere e.g. across different libraries - Vue, React, Angular etc.\n","n":0.092}}},{"i":5,"$":{"0":{"v":"Rendering Design Patterns","n":0.577},"1":{"v":"\n## CSR (Client-Side Rendering) / SPA (Single Page Application)\n\n> the data is fetched after every single render\n\nMost common way of using frameworks such as React, vue, ember etc.\n\nClient-side rendering means that a website’s JavaScript is rendered in your browser, rather than on the website’s server.\n\n- The server renders a blank page with a script tag pointing to the apps bundle\n- blank page is sent to the clients browser which makes the relevant api calls and renders the contents of the page\n\nstrengths:\n\n- renders fast on the server\n\nweaknesses:\n\n- no initial render - customer/client has to render so if the app is big it could be a problem\n\n- empty body - no content to crawl for a search engine - ** SEO is the biggest weak point **\n\n## SSR (Server Side Rendering)\n\n> the data is fetched before every single render\n\nWhen the user makes a request to the webpage, the server prepares the html page and then sends it back.\n\n## SSG (Static-Site Generating)\n\n> the data is fetched once at build time\n\nPage is also generated on the server however it is rendered at **build time.**\n\n## ISR (Incremental Static Regeneration)\n\n> the data is fetched once on build time and will be fetched again after a certain cooldown and served on the second visit.\n\nAllows you to create or update static pages after you've built your site. This gives you the benefit of using static generation without needing to rebuild the entire site.\n\n## When to use what?\n\n- Is your content dynamic or relatively static?\n\n- is SEO important?\n\nHere are some examples from [this article](https://medium.com/codex/web-design-patterns-ssr-ssg-and-spa-fadad7673dfe#:~:text=SSR%20vs%20SSG,I%20use%20SSR%20then%3F%22.)\n\n> For a documentation page or a website that doesn't need to fetch dynamic data, but SEO is important, you could use SSG.\n> For a blog, SEO is important and the content is dynamic. In this case, SSR could be a good candidate.\n> For a CRM (Customer Relationship Manager), SEO is not a concern and the content is dynamic therefore an SPA/CSR would be a good choice.\n\nMany websites will use a combination. These days for anything that is not an SPA, it's often recommended to use SSG practically all of the time unless there is a good reason not to e.g. the website is massive with dynamic content that cannot be pre-rendered as it changes frequently. [Next JS recommends SSG ](https://nextjs.org/docs/basic-features/pages#pre-rendering) for many use cases. The alternative is to use ISR for a website with mostly static content but for a web page with thousands of pages in order to prevent a complete rebuild every time.\n\n> \"We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option.\"\n\nSome important considerations:\n\n1. Data Integrity - how fresh do we want the data? CSR and SSR fetch on every render.\n\n2. SEO - SSR, SSG and ISR are SEO friendly given crawlers don't have to wait for a page to load to get relevant data\n3. Performance - SSG and ISR load instantly (for first contentful paint)\n4. Build Time - the amount of time it takes to build and deploy the website is slower for SSG and ISR since we need to build all the pages to serve where as CSR and ISR build pages dynamically.\n\n##### References\n\n1. https://theodorusclarence.com/blog/nextjs-fetch-usecase\n","n":0.043}}},{"i":6,"$":{"0":{"v":"Projects","n":1}}},{"i":7,"$":{"0":{"v":"Operation Rewrite","n":0.707},"1":{"v":"\n## Project: Operation Re-write (Purposely obscure)\n\n### Problem:\n\nExisting site is slow and difficult to improve given it's built in wordpress. Gives limited options for improvement from a developer perspective without adding more bloat and plugins. Owned by non-for-profit therefore budget is an important consideration.\n\n### Solution:\n\nRe-write using headless CMS and following JAMSTACK princples.\n\n### Existing stack\n\n- Frontend: PHP\n- Backend: PHP\n- CMS: Wordpress\n- DB: SQL\n\n### Proposed re-architected stack:\n\n- Frontend: React framework\n- Backend - possibly NodeJS with GraphQL\n- CMS: Headless\n- DB: ?? not sure if I need one\n\n### Rendering Style\n\nRef [[web.frontend.designpatterns]]\n\nOptions: SSR, SSG, SPA, ISR\n\nContent is mostly static - new blog posts written relatively infrequently. There is an ecommerce section with a small number of products. No comments or anything else that is dynamic at the moment.\n\nSSG could be a good option here but a framework that supports SSR as well could be useful for any future concerns. Maybe best of both worlds and use ISR? No need to rebuild every time we change a post or add a product.\n\n### Framework Options\n\n- Remix - looks good but pretty new\n- Next - established, but maybe bloated for my use case? Needs a server to run for ISR and SSR\n- Gatsby - only does SSG (?)\n\n### Headless CMS Options\n\n- Strapi - free/open source\n- Contentful - recommended but paid after certain point\n\n### DB?\n\nDo I need?\n\n- PSQL\n\n## Build steps\n\n1. Set up CMS\n2. Set up FE\n3. interface the two\n","n":0.066}}},{"i":8,"$":{"0":{"v":"Programming Paradigms","n":0.707},"1":{"v":"\n**Programming paradigm refers to a style of programming.** Programming languages need to follow some strategy when they are implemented known as a paradigm.\n\nThere are two significant paradigms programming languages fall into - **Imperative** and **Declarative**. These categories have various subtypes:\n\n```mermaid\ngraph TD;\n    D[Imperitive]-->P[Procedural];\n    D --> O[Object Oriented]\n```\n\n```mermaid\ngraph TD;\n    D[Declarative]-->L[Logic];\n    D --> F[Functional]\n```\n\n## Imperative\n\nThe word “imperative” comes from the Latin “impero” meaning “I command”. This is the oldest programming paradigm. It effectively means the code is a series of commands executed in order to achieve a result.\n\nImperative tells a program exactly how to do something. For example, if we need a program to print numbers in an array that are less than 10:\n\n```Javascript\n    const nums = [5, 10, 15, 8, 7]\n    let lessThanTen = []\n\n    for(i = 0; i < nums.length; i++) {\n        if(nums[i] < 10) {\n            lessThanTen.push(nums[i]);\n        }\n    }\n\n    // prints [5, 8, 7]\n    console.log(lessThanTen)\n```\n\n## Declarative\n\nDeclarative programming focuses on the end result as opposed to how to get there. For example, if we need a program to print numbers in an array that are less than 10:\n\n```Javascript\n    const nums = [5, 10, 15, 8, 7]\n    // prints [5, 8, 7]\n    console.log(nums.filter(num => num < 10))\n```\n\nReact is a declarative framework as rather than telling it how to render (in the same way you do with vanilla JS), you tell it what you want it to render.\n\n## Types of Imperative Programming\n\n### Procedural Programming\n\nBuilt around the idea that programs are sequences of instructions to be executed - splits up programs into 'procedures' or functions. This is effectively the same as imperative with the idea of using code splitting and enhancing reusability with subroutines.\n\n```Javascript\n    // use a function (procedural)\n    function getNumbersLessThanTen(nums) {\n        let lessThanTen = []\n        for(i = 0; i < nums.length; i++) {\n            if(nums[i] < 10) {\n                lessThanTen.push(nums[i]);\n            }\n        }\n        return lessThanTen\n\n    }\n\n\n    // prints [5, 8, 7]\n    console.log(getNumbersLessThanTen([5, 10, 15, 8, 7]))\n```\n\n### Object-oriented Programming\n\nOOP was introduced in order to overcome procedural programming limitations. In OOP, code is organised into objects and classes. In conventional procedural programming, data was global and there was a difficulty in securing the program from unintended changes. OOP controls access to data via encapsulation within classes.\n\nThe main priniciples of OOP are:\n\n1. Encapsulation\n2. Inheritance\n3. Abstraction\n4. Polymorphism\n\n## Types of Declarative Programming\n\n### Logical programming\n\nMade up of facts and rules and foundationally mathematical. It takes a declarative approach to problem solving by using everything it knows and trying to answer whether the given facts and clauses are true. For example, if the code states that A is equal to B and B is equal to C, a logical program will make the logical conclusion that A must be equal to C.\n\nExamples of languages that use logic programming paradigm are Prolog, Absys or Alice.\n\n### Functional programming\n\nFunctional programming is language independent. FP is the process of building software by composing pure functions, avoiding shared state, mutable data and side effects. JavaScript is a notable example of a language that fundemnatally supports the functional paradigm.\n\nA pure function is one which, given the same inputs, always returns the same output and has no side effects. This is an important aspect of functional programming. The idea is that functions are not dependent on local or global state.\n\nFunctions are described as \"first class objects\" in functional programming. The reason is that functions can be assigned to variables, passed as arguments, and returned from other functions, just as any other data type can.\n\n```JavaScript\n\n// assign function to variable!\nlet log = function(someVariable) {\n    console.log(someVariable);\n    return someVariable;\n}\n\n\nlet myVar = \"Hello world\";\n\nlog(myVar);\n// Hello world\n```\n","n":0.042}}},{"i":9,"$":{"0":{"v":"Agile","n":1},"1":{"v":"\nThe ability to respond to **change**.\n\nAgile software development is iterative, focusing on small increments and evolving requirements.\n\nAgile development refers to any development process that is aligned with the concepts of the Agile [[agile.manifesto]]\n","n":0.174}}},{"i":10,"$":{"0":{"v":"Manifesto","n":1},"1":{"v":"\nTODO\n","n":1}}}]}
